#ifndef UEP_RNG_HPP
#define UEP_RNG_HPP

#include <algorithm>
#include <functional>
#include <random>
#include <vector>

/** Implement a discrete distribution with elements in [1,K] according
 *  to a specified PMD.
 */
class degree_distribution {
public:
  /** Type of the PMD function. */
  typedef std::function<double(std::size_t)> pmd_t;

  /** Use the PMD to build the discrete distribution in [1,K]. */
  explicit degree_distribution(std::size_t K, const pmd_t &pmd);
  /** Correct destruction when used polymorphically. */
  virtual ~degree_distribution() = default;
  /** The maximum degree. */
  std::size_t K() const;
  /** The PMD function. */
  pmd_t pmd() const;
  /** Generate a degree using the RNG g. */
  template<class Gen> std::size_t operator()(Gen &g);

private:
  const std::size_t K_;
  const pmd_t pmd_;
  std::discrete_distribution<std::size_t> distrib;
};

/** Produces soliton-distributed random numbers. */
class soliton_distribution : public degree_distribution {
public:
  /** Returns the soliton probability mass distribution for a certain
   *  blocksize K and degree d.
   */
  static double soliton_pmd(std::size_t K, std::size_t d);

  explicit soliton_distribution(std::size_t input_pkt_count);
};

/** Produces robust-soliton-distributed random numbers. */
class robust_soliton_distribution : public degree_distribution {
public:
  static double S(std::size_t K, double c, double delta);
  static double tau(std::size_t K_S, double S_delta, std::size_t i);
  static double beta(std::size_t K, std::size_t K_S, double S_delta);
  static double robust_pmd(std::size_t K, double c, double delta, std::size_t d);

  explicit robust_soliton_distribution(std::size_t input_pkt_count, double c, double delta);
  /** Return the c coefficient */
  double c() const;
  /** Return the delta_max parameter */
  double delta() const;
  /** Return the PMD normalization coefficient */
  double beta() const;

private:
  const double c_;
  const double delta_;
};

/** Chooses uniformly which input packets to mix into the next coded
 *  packet, using the degree generated by a degree_distribution.
 */
class lt_row_generator {
public:
  typedef std::mt19937 rng_type;
  typedef std::vector<std::size_t> row_type;

  /** Construct using the specified degree distribution */
  explicit lt_row_generator(const degree_distribution &deg);
  /** Construct using the specified degree distribution and
   *  RNG seed.
   */
  explicit lt_row_generator(const degree_distribution &deg,
			    rng_type::result_type seed);
  /** Generate the next packet selection. */
  row_type next_row();
  /** Return the number of rows already generated. */
  std::size_t generated_rows() const;
  /** Return the input blocksize */
  std::size_t K() const;
  /** The last seed used to setup the row generator */
  rng_type::result_type seed() const;
  /** Reset to the initial state using the default seed */
  void reset();
  /** Reset to the initial state using the specified seed */
  void reset(rng_type::result_type seed);

private:
  rng_type generator;
  degree_distribution degree_distr;
  std::uniform_int_distribution<std::size_t> packet_distr;
  std::size_t sel_count;
  rng_type::result_type last_seed;
};

/** Build an lt_row_generator using a robust_soliton_distribution */
lt_row_generator make_robust_lt_row_generator(std::size_t K, double c, double delta);

// Template definitions

template<class Gen>
std::size_t degree_distribution::operator()(Gen &g) {
  return distrib(g) + 1;
}

#endif
