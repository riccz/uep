#ifndef RNG_HPP
#define RNG_HPP

#include <algorithm>
#include <cstdint>
#include <random>
#include <vector>

/** Produces soliton-distributed random numbers. */
class soliton_distribution {
public:
  /** Returns the soliton probability mass distribution for a certain
   *  blocksize K and degree d.
   */
  static double soliton_pmd(std::uint_fast32_t K, std::uint_fast32_t d);
  
  explicit soliton_distribution(std::uint_fast32_t input_pkt_count);
  /** Generate a new number using the generator g. */
  template<class Generator>
  std::uint_fast32_t operator()(Generator &g);
  /** Return the input block size. */
  std::uint_fast32_t K() const;

private:
  const std::uint_fast32_t K_;
  std::discrete_distribution<std::uint_fast32_t> distrib;
};

class robust_soliton_distribution {
public:
  static double S(std::uint_fast32_t K,
		  double c,
		  double delta);
  static double tau(std::uint_fast32_t K,
		    double c,
		    double delta,
		    std::uint_fast32_t i);
  static double beta(std::uint_fast32_t K,
		     double c,
		     double delta);
  static double robust_pmd(std::uint_fast32_t K,
			   double c,
			   double delta,
			   std::uint_fast32_t d);
    
  explicit robust_soliton_distribution(std::uint_fast32_t input_pkt_count,
				       double c,
				       double delta);
  /** Generate a new number using the generator g. */
  template<class Generator>
  std::uint_fast32_t operator()(Generator &g);
  /** Return the input block size. */
  std::uint_fast32_t K() const;
  /** Return the c parameter */
  double c() const;
  /** Return the delta_max parameter */
  double delta() const;

private:
  const std::uint_fast32_t K_;
  const double c_;
  const double delta_;
  std::discrete_distribution<std::uint_fast32_t> distrib;
};

/** Chooses at random which input packets to mix into the next coded
 *  packet using the degree generated by an object of type DegT.
 */
template <class DegT>
class fountain_ {
public:
  typedef std::mt19937 generator_type;
  typedef DegT degree_distribution_type;
  typedef std::vector<std::uint_fast32_t> row_type;

  /** Build a new fountain using the default seed. */
  explicit fountain_(std::uint_fast32_t input_pkt_count);
  /** Build a new fountain using the specified seed. */
  explicit fountain_(std::uint_fast32_t input_pkt_count,
		     generator_type::result_type seed);
  /** Generate the next packet selection. */
  row_type next_row();
  /** Return the number of packet selections already generated. */
  typename row_type::size_type generated_rows() const;
  /** Return the input blocksize */
  std::uint_fast32_t K() const;
  /** Reset to the initial state using the default seed */
  void reset();
  /** Reset to the initial state using the specified seed */
  void reset(generator_type::result_type seed);

private:
  const std::uint_fast32_t K_;
  generator_type generator;
  DegT degree_distr;
  std::uniform_int_distribution<std::uint_fast32_t> packet_distr;
  typename row_type::size_type sel_count;
};

typedef fountain_<soliton_distribution> fountain;

// Template defintions

template<class Generator>
std::uint_fast32_t soliton_distribution::operator()(Generator &g) {
  return distrib(g)+1;
}

template<class Generator>
std::uint_fast32_t robust_soliton_distribution::operator()(Generator &g) {
  return distrib(g)+1;
}

template <class DegT>
fountain_<DegT>::fountain_(uint_fast32_t input_pkt_count) :
  K_(input_pkt_count),
  degree_distr(K_),
  packet_distr(0, K_-1),
  sel_count(0) {
}

template <class DegT>
fountain_<DegT>::fountain_(uint_fast32_t input_pkt_count,
		   generator_type::result_type seed) :
  fountain_(input_pkt_count) {
  generator.seed(seed);
}

template <class DegT>
typename fountain_<DegT>::row_type fountain_<DegT>::next_row() {
  uint_fast32_t degree = degree_distr(generator);
  row_type s;
  s.reserve(degree);
  for (uint_fast32_t i = 0; i < degree; i++) {
    uint_fast32_t si;
    do {
      si = packet_distr(generator);
    }	while (find(s.begin(), s.end(), si) != s.end());
    s.push_back(si);
  }
  sel_count++;
  return s;
}

template <class DegT>
typename fountain_<DegT>::row_type::size_type fountain_<DegT>::generated_rows() const {
  return sel_count;
}

template <class DegT>
uint_fast32_t fountain_<DegT>::K() const {
  return K_;
}

template <class DegT>
void fountain_<DegT>::reset() {
  generator.seed();
  sel_count = 0;
}

template <class DegT>
void fountain_<DegT>::reset(generator_type::result_type seed) {
  generator.seed(seed);
  sel_count = 0;
}

#endif
