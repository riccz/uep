#ifndef UEP_RNG_HPP
#define UEP_RNG_HPP

#include <algorithm>
#include <functional>
#include <random>
#include <vector>

/** Implement a discrete distribution with elements in [1,K] according
 *  to a specified PMD.
 */
class degree_distribution {
public:
  /** Type of the PMD function. */
  typedef std::function<double(std::size_t)> pmd_t;

  /** Use the PMD to build the discrete distribution in [1,K]. */
  explicit degree_distribution(std::size_t K, const pmd_t &pmd);
  /** Correct destruction when used polymorphically. */
  virtual ~degree_distribution() = default;
  /** The maximum degree. */
  std::size_t K() const;
  /** The PMD function. */
  pmd_t pmd() const;
  /** Generate a degree using the RNG g. */
  template<class Gen> std::size_t operator()(Gen &g);

private:
  std::size_t K_;
  pmd_t pmd_;
  std::discrete_distribution<std::size_t> distrib;
};

/** Produces soliton-distributed random numbers. */
class soliton_distribution : public degree_distribution {
public:
  /** Returns the soliton probability mass distribution for a certain
   *  blocksize K and degree d.
   */
  static double soliton_pmd(std::size_t K, std::size_t d);

  explicit soliton_distribution(std::size_t input_pkt_count);
};

/** Produces robust-soliton-distributed random numbers. */
class robust_soliton_distribution : public degree_distribution {
public:
  static double S(std::size_t K, double c, double delta);
  static double tau(std::size_t K_S, double S_delta, std::size_t i);
  static double beta(std::size_t K, std::size_t K_S, double S_delta);
  static double robust_pmd(std::size_t K, double c, double delta, std::size_t d);

  explicit robust_soliton_distribution(std::size_t input_pkt_count, double c, double delta);
  /** Return the c coefficient */
  double c() const;
  /** Return the delta_max parameter */
  double delta() const;
  /** Return the PMD normalization coefficient */
  double beta() const;

private:
  double c_;
  double delta_;
};

/** Base abstract class for a row generator. The generated rows
 *  contain the indices of the packets to XOR to produce the next
 *  coded packet.
 */
class base_row_generator {
public:
  /** Type of the random generator used. */
  using rng_type = std::mt19937;
  /** Type of the produced rows. */
  using row_type = std::vector<std::size_t>;

  /** Virtual default destructor. */
  virtual ~base_row_generator() = default;

  /** Generate the next row. This must be implemented by a subclass. */
  virtual row_type next_row() = 0;
  /** Return the block size. This must be implemented by a subclass. */
  virtual std::size_t K() const = 0;

  /** Reset the random generator using the given seed. */
  virtual void reset(rng_type::result_type seed = rng_type::default_seed);

  /** Number of rows generated since the last reset. */
  std::size_t generated_rows() const;
  /** Value of the seed provided at the last reset. */
  rng_type::result_type seed() const;

protected:
  rng_type rng;
  std::size_t sel_count;
  rng_type::result_type last_seed;

  explicit base_row_generator(rng_type::result_type seed = rng_type::default_seed);
};

/** Chooses uniformly which input packets to mix into the next coded
 *  packet, using the degree generated by a degree_distribution.
 */
class lt_row_generator : public base_row_generator {
public:
  using base_row_generator::rng_type;
  using base_row_generator::row_type;

  /** Construct using the specified degree distribution */
  explicit lt_row_generator(const degree_distribution &deg);
  /** Construct using the specified degree distribution and
   *  RNG seed.
   */
  explicit lt_row_generator(const degree_distribution &deg,
			    rng_type::result_type seed);

  virtual ~lt_row_generator() override = default;

  /** Generate the next packet selection. */
  virtual row_type next_row() override;
  /** Return the input blocksize */
  virtual std::size_t K() const override;

private:
  degree_distribution degree_distr;
  std::uniform_int_distribution<std::size_t> packet_distr;
};

/** Shorthand to build an lt_row_generator using a
 *  robust_soliton_distribution
 */
lt_row_generator make_robust_lt_row_generator(std::size_t K, double c, double delta);

// Template definitions

template<class Gen>
std::size_t degree_distribution::operator()(Gen &g) {
  return distrib(g) + 1;
}

#endif
