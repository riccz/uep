#ifndef UEP_RNG_HPP
#define UEP_RNG_HPP

#include <algorithm>
#include <functional>
#include <random>
#include <vector>

/** Implement a discrete distribution with elements in [1,K] according
 *  to a specified PMD.
 */
class degree_distribution {
public:
  /** Type of the PMD function. */
  typedef std::function<double(std::size_t)> pmd_t;

  /** Use the PMD to build the discrete distribution in [1,K]. */
  explicit degree_distribution(std::size_t K, const pmd_t &pmd);
  /** Correct destruction when used polymorphically. */
  virtual ~degree_distribution() = default;
  /** The maximum degree. */
  std::size_t K() const;
  /** The PMD function. */
  pmd_t pmd() const;
  /** Generate a degree using the RNG g. */
  template<class Gen> std::size_t operator()(Gen &g);

private:
  std::size_t K_;
  pmd_t pmd_;
  std::discrete_distribution<std::size_t> distrib;
};

/** Produces soliton-distributed random numbers. */
class soliton_distribution : public degree_distribution {
public:
  /** Returns the soliton probability mass distribution for a certain
   *  blocksize K and degree d.
   */
  static double soliton_pmd(std::size_t K, std::size_t d);

  explicit soliton_distribution(std::size_t input_pkt_count);
};

/** Produces robust-soliton-distributed random numbers. */
class robust_soliton_distribution : public degree_distribution {
public:
  static double S(std::size_t K, double c, double delta);
  static double tau(std::size_t K_S, double S_delta, std::size_t i);
  static double beta(std::size_t K, std::size_t K_S, double S_delta);
  static double robust_pmd(std::size_t K, double c, double delta, std::size_t d);

  explicit robust_soliton_distribution(std::size_t input_pkt_count, double c, double delta);
  /** Return the c coefficient */
  double c() const;
  /** Return the delta_max parameter */
  double delta() const;
  /** Return the PMD normalization coefficient */
  double beta() const;

private:
  double c_;
  double delta_;
};

/** Base abstract class for a row generator. The generated rows
 *  contain the indices of the packets to XOR to produce the next
 *  coded packet.
 */
class base_row_generator {
public:
  /** Type of the random generator used. */
  using rng_type = std::mt19937;
  /** Type of the produced rows. */
  using row_type = std::vector<std::size_t>;

  /** Virtual default destructor. */
  virtual ~base_row_generator() = default;

  /** Generate the next row. This must be implemented by a subclass. */
  virtual row_type next_row() = 0;
  /** Return the block size. This must be implemented by a subclass. */
  virtual std::size_t K() const = 0;

  /** Reset the random generator using the given seed. */
  virtual void reset(rng_type::result_type seed = rng_type::default_seed);

  /** Number of rows generated since the last reset. */
  std::size_t generated_rows() const;
  /** Value of the seed provided at the last reset. */
  rng_type::result_type seed() const;

protected:
  rng_type rng;
  std::size_t sel_count;
  rng_type::result_type last_seed;

  explicit base_row_generator(rng_type::result_type seed = rng_type::default_seed);
};

/** Chooses uniformly which input packets to mix into the next coded
 *  packet, using the degree generated by a degree_distribution.
 */
class lt_row_generator : public base_row_generator {
public:
  using base_row_generator::rng_type;
  using base_row_generator::row_type;

  /** Construct using the specified degree distribution */
  explicit lt_row_generator(const degree_distribution &deg);
  /** Construct using the specified degree distribution and
   *  RNG seed.
   */
  explicit lt_row_generator(const degree_distribution &deg,
			    rng_type::result_type seed);

  virtual ~lt_row_generator() override = default;

  /** Generate the next packet selection. */
  virtual row_type next_row() override;
  /** Return the input blocksize */
  virtual std::size_t K() const override;

private:
  degree_distribution degree_distr;
  std::uniform_int_distribution<std::size_t> packet_distr;
};

namespace uep {

/** Map the positions from the UEP expanded block to the positions in
 *  the original block.
 */
class position_mapper {
public:
  template<typename KsIter, typename RFsIter>
  explicit position_mapper(KsIter ks_begin, KsIter ks_end,
			   RFsIter rfs_begin, RFsIter rfs_end,
			   std::size_t EF) {
    std::vector<std::size_t> Ks(ks_begin, ks_end);
    std::vector<std::size_t> RFs(rfs_begin, rfs_end);

    std::size_t K_out = EF * std::inner_product(Ks.cbegin(), Ks.cend(),
						RFs.cbegin(), 0);
    map.resize(K_out);
    auto i = map.begin();
    std::size_t offset = 0;

    for (std::size_t k = 0; k < Ks.size(); ++k) {
      std::iota(i, i + Ks[k], offset);
      auto sb_start = i;
      i += Ks[k];
      for (std::size_t r = 1; r < RFs[k]; ++r){
	i = std::copy(sb_start, sb_start + Ks[k], i);
      }
      offset += Ks[k];
    }

    auto first_rep_end = i;
    for (std::size_t e = 1; e < EF; ++e) {
      i = std::copy(map.begin(), first_rep_end, i);
    }
  }

  std::size_t operator()(std::size_t pos) const {
    return map.at(pos);
  }

private:
  std::vector<std::size_t> map;
};

/** Generate row indices according to the UEP method. */
class uep_row_generator : public base_row_generator {
  using base_row_generator::rng_type;
  using base_row_generator::row_type;

public:
  template<typename KsIter, typename RFsIter>
  explicit uep_row_generator(KsIter ks_begin, KsIter ks_end,
			     RFsIter rfs_begin, RFsIter rfs_end,
			     std::size_t ef,
			     double c,
			     double delta);

  virtual ~uep_row_generator() override = default;

  virtual row_type next_row() override;
  virtual std::size_t K() const override;

  std::size_t K_in() const;
  std::size_t K_out() const;
  const std::vector<std::size_t> &Ks() const;
  const std::vector<std::size_t> &RFs() const;
  std::size_t EF() const;
  double c() const;
  double delta() const;
private:
  std::vector<std::size_t> _ks;
  std::vector<std::size_t> _rfs;
  std::size_t _ef;
  double _c;
  double _delta;

  std::size_t _k_in;
  std::size_t _k_out;

  robust_soliton_distribution _deg_dist;
  std::uniform_int_distribution<std::size_t> _p_dist;
  position_mapper _pos_map;
};

}

/** Shorthand to build an lt_row_generator using a
 *  robust_soliton_distribution
 */
lt_row_generator make_robust_lt_row_generator(std::size_t K, double c, double delta);

// Template definitions

template<class Gen>
std::size_t degree_distribution::operator()(Gen &g) {
  return distrib(g) + 1;
}

	   //// uep_row_generator template definitions ////
namespace uep {

template<typename KsIter, typename RFsIter>
uep_row_generator::uep_row_generator(KsIter ks_begin, KsIter ks_end,
				     RFsIter rfs_begin, RFsIter rfs_end,
				     std::size_t ef,
				     double c,
				     double delta) :
_ks(ks_begin, ks_end),
_rfs(rfs_begin, rfs_end),
_ef(ef),
_c(c),
_delta(delta),
_k_in(std::accumulate(_ks.cbegin(), _ks.cend(), 0)),
_k_out(_ef * std::inner_product(_ks.cbegin(), _ks.cend(),
				_rfs.cbegin(), 0)),
_deg_dist(_k_out, _c, _delta),
_p_dist(0, _k_out - 1),
_pos_map(ks_begin, ks_end, rfs_begin, rfs_end, ef) {
  if (_ks.size() != _rfs.size())
    throw std::invalid_argument("Ks, RFs size mismatch");
  if (_ks.empty())
    throw std::invalid_argument("Empty Ks, RFs");
}

}

#endif
