#ifndef ENCODER_HPP
#define ENCODER_HPP

#include "log.hpp"
#include "packets.hpp"
#include "rng.hpp"
#include "utils.hpp"

#include <limits>
#include <queue>
#include <stdexcept>
#include <vector>
#include <utility>

/** Standard LT-code encoder.
 *
 *  The encoder receives input packets via push_input, stores them in
 *  a FIFO queue and produces one encoded packet at a time via
 *  next_coded. The packets are XORed according to the rows generated
 *  by a fountain. The seed for the fountain is generated at each new
 *  block of K packets by calling an object of class Gen.
 *
 *  \sa fountain_decoder fountain
 */
template<class Gen = std::random_device>
class fountain_encoder {
public:
  /** The type of the object called to seed the fountain's RNG at each
   *  new block.
   */
  typedef Gen seed_generator_type;

  /** Maximum allowed value for the sequence numbers.
   *  If the encoder tries to generate more packets from a single
   *  input block, an exception is thrown.
   */
  static const int MAX_SEQNO = 0xffff;
  /** Maximum allowed value for the block numbers.
   *  When the encoder goes past this value it loop back to zero.
   */
  static const int MAX_BLOCKNO = 0xffff;

  /** Construct using a fountain with degree distribution distr. */
  explicit fountain_encoder(const degree_distribution &distr);
  /** Construct with the fountain f. */
  explicit fountain_encoder(const fountain &f);

  /** Enqueue packet p in the input queue. */
  void push_input(const packet &p);
  /** Enqueue packet p in the input queue. */
  void push_input(packet &&p);
  /** Generate the next coded packet from the current block and a new
   *  row generated by the fountain.
   */
  fountain_packet next_coded();
  /** Drop the current block of packets and prepare to encode the next
   *  one.
   */
  void discard_block();

  /** Return true when the encoder has been passed at least K blocks
   *  and is ready to produce a coded packet.
   */
  bool has_block() const;
  /** The block size. */
  int K() const;
  /** The sequence number of the current block. */
  int blockno() const;
  /** The sequence number of the next packet to be generated. */
  int seqno() const;
  /** The seed used in the current block. */
  int block_seed() const;
  /** The number of queued packets. */
  size_t queue_size() const;

  fountain the_fountain() const;
  seed_generator_type the_seed_generator() const;
  std::vector<packet>::const_iterator current_block_begin() const;
  std::vector<packet>::const_iterator current_block_end() const;

private:
  struct loggers_t {
    default_logger enc_pkts = make_stat_logger("EncoderCodedPackets", counter);
    default_logger in_pkts = make_stat_logger("EncoderInputPackets", counter);
    default_logger newblock = make_stat_logger("EncoderNewBlock", counter);
    default_logger rows = make_stat_logger("EncoderRowDegree", scalar);
    default_logger text;
  } loggers;

  fountain fount;
  int blockno_;
  int block_seed_;
  int seqno_;
  std::queue<packet> input_queue;
  std::vector<packet> input_block;
  seed_generator_type seed_gen;

  bool next_seqno_will_overflow;

  void check_has_block();
  int next_seed();
};

// Template definitions

template<class Gen>
fountain_encoder<Gen>::fountain_encoder(const degree_distribution &distr) :
  fountain_encoder(fountain(distr)) {
}

template<class Gen>
fountain_encoder<Gen>::fountain_encoder(const fountain &f) :
  fount(f), blockno_(0), seqno_(0), next_seqno_will_overflow(false) {
  input_block.reserve(f.K());
  block_seed_ = next_seed();
  fount.reset(block_seed_);
}

template<class Gen>
void fountain_encoder<Gen>::push_input(packet &&p) {
  PUT_STAT_COUNTER(loggers.in_pkts);
  BOOST_LOG_SEV(loggers.text, debug) << "Pushed a packet to the encoder";
  input_queue.push(std::move(p));
  check_has_block();
}

template<class Gen>
void fountain_encoder<Gen>::push_input(const packet &p) {
  packet p_copy(p);
  push_input(std::move(p_copy));
}

template<class Gen>
fountain_packet fountain_encoder<Gen>::next_coded() {
  if (!has_block())
    throw std::runtime_error("Does not have a full block");
  if (next_seqno_will_overflow)
    throw std::runtime_error("Seqno overflow");
  auto sel = fount.next_row(); // genera riga
  PUT_STAT_SCALAR(loggers.rows, sel.size());
  auto i = sel.cbegin(); // iteratore sulla riga
  fountain_packet first(input_block[*i]); // mette dentro first una copia dell'input
  i++;
  for (; i != sel.end(); i++) { // begin == end Ã¨ la condizione di fine ciclo
    first ^= input_block[*i];
  }
  first.block_number(blockno_);
  first.block_seed(block_seed_);
  first.sequence_number(seqno_); // seqno: = prossimo seq. number del pacchetto da inviare
  if (seqno_ == MAX_SEQNO)
    next_seqno_will_overflow = true;
  else
    ++seqno_;
  PUT_STAT_COUNTER(loggers.enc_pkts);
  BOOST_LOG_SEV(loggers.text, debug) << "New encoded packet: " << first;
  return first;
}

template<class Gen>
void fountain_encoder<Gen>::discard_block() {
  input_block.clear();
  block_seed_ = next_seed();
  fount.reset(block_seed_);
  if (blockno_ == MAX_BLOCKNO)
    blockno_ = 0;
  else
    blockno_++;
  seqno_ = 0;
  next_seqno_will_overflow = false;
  PUT_STAT_COUNTER(loggers.newblock);
  BOOST_LOG_SEV(loggers.text, debug) << "Discard block. New blockno=" <<
    blockno_ << ", new seed=" << block_seed_;
  check_has_block();
}

template<class Gen>
bool fountain_encoder<Gen>::has_block() const {
  return input_block.size() == (size_t)K();
}

template<class Gen>
int fountain_encoder<Gen>::K() const {
  return fount.K();
}

template<class Gen>
int fountain_encoder<Gen>::blockno() const {
  return blockno_;
}

template<class Gen>
int fountain_encoder<Gen>::seqno() const {
  return seqno_;
}

template<class Gen>
int fountain_encoder<Gen>::block_seed() const {
  return block_seed_;
}

template <class Gen>
size_t fountain_encoder<Gen>::queue_size() const {
  return input_queue.size();
}

template<class Gen>
fountain fountain_encoder<Gen>::the_fountain() const {
  return fount;
}

template<class Gen>
Gen fountain_encoder<Gen>::the_seed_generator() const {
  return seed_gen;
}

template<class Gen>
std::vector<packet>::const_iterator
fountain_encoder<Gen>::current_block_begin() const {
  return input_block.cbegin();
}

template<class Gen>
std::vector<packet>::const_iterator
fountain_encoder<Gen>::current_block_end() const {
  return input_block.cend();
}

template<class Gen>
void fountain_encoder<Gen>::check_has_block() {
  if (!has_block() && input_queue.size() >= (size_t)K()) {
    for (int i = 0; i < K(); i++) {
      packet p;
      std::swap(p, input_queue.front());
      input_queue.pop();
      input_block.push_back(std::move(p));
    }
  }
}

template<class Gen>
int fountain_encoder<Gen>::next_seed() {
  return seed_gen();
}

#endif
